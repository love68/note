## 简介

> 用户在命令行输入命令后，一般情况下Shell会fork并exec该命令，但是shell的内建命令例外，执行内建命令相当于调用Shell进程中的一个函数，并不插件新的进程。凡是用which命令查不到程序文件所在位置的命令都是内建命令，内建命令没有单独的man手册，要在man手册中查看内建命令，应该

```sh
man bash-builtins
```

> 内建命令虽然不创建新的进程，但也会有Exit Status，通常也用0表示成功非零表示失败，虽然内建命令不创建新的进程，但执行结束后也会有一个状态码，也可以用特殊变量$?读出。    echo $   $?

## 执行shell

- 方式1：先授权，chmod a+x 文件名，获得执行权限。
- 方式2： /bin/sh ./test/sh

注意：在命令行中输入的命令用()括号括起来，那么也会fork出一个子Shell执行小括号中的命令，一行中可以输入由分号;隔开的多个命令。比如

```sh
$ (cd ..;ls -l)
```

> cd ..命令改变的是子Shell的PWD，不会影响到交互式Shell，会创建子shell

然而命令

```sh
$ cd ..;ls -l
```

会有不同的效果，cd ..命令是直接在交互式Shell下执行的，改变交互式Shell的PWD。不会创建子shell

> ```sh
> $ source ./test.sh 或者 $ . ./test.sh
> ```

这两种方式也不会创建子Shell，而是直接在交互式Shell下逐行执行脚本中的命令。



## 基本语法

### 变量

> 按照惯例，Shell变量由全大写字母加下划线组成

1. 环境变量

> 环境变量可以从父进程传给子进程，shell进程的环境变量可以从当前shell进程传给fork出来的子进程。用printenv命令可以显示当前shell进程的环境变量。

2. 本地变量

> 只存在于当前shell进程，用set命令可以显示当前shell进程中定义的所有变量（包括本地变量和环境变量）和函数。

#### 定义变量

> 变量名=值

注意等号两边都不能有空格，否则会被Shell解释成命令和命令行参数。一个变量定义后仅存在于当前shell进程，是本地变量，用export可以把本地变量导出为环境变量

```sh
export 变量名 或者 export 变量名=值
```

#### 删除变量

```sh
unset 变量名
```

#### 取值

> 如果一个变量叫做VARNAME，用${VARNAME}可以表示它的值，在不引起歧义的情况下也可以用$VARNAME表示它的值。Shell变量不需要明确定义类型，事实上Shell变量的值都是字符串,如果对一个没有定义的变量取值，则值为空字符串。

### 文件名代换

```sh
*   匹配0个或多个任意字符
?   匹配一个任意字符
[若干字符]  匹配方括号中任意一个字符的一次出现

$ ls /dev/ttyS*
$ ls ch0?.doc
$ ls ch0[0-2].doc
$ ls ch[012]   [0-9].doc
```

> 注意，Globbing所匹配的文件名是由Shell展开的，也就是说在参数还没传给程序之前已经展开了，比如上述ls ch0[012].doc命令，如果当前目录下有ch00.doc和ch02.doc，则传给ls命令的参数实际上是这两个文件名，而不是一个匹配字符串。

### 命令代换：`或 $()

由'`'反引号括起来的也是一条命令，Shell先执行该命令，然后将输出结果立刻代换到当前命令行中。例如定义一个变量存放date命令的输出：

```sh
[root@hasee ~]# DATE=`date`
[root@hasee ~]# echo $DATE
2019年 01月 04日 星期五 16:15:16 CST
```

或

```sh
[root@hasee ~]# D=$(date)
[root@hasee ~]# echo $D
2019年 01月 04日 星期五 16:16:17 CST
```

### 算术代换：$(())

> $(())中只能用+-*/和()运算符，并且只能做整数运算。
>
> ```
> $[base#n],其中base表示进制,n按照base进制解释，后面再有运算数，按十进制解释。
> [root@hasee ~]# echo $[2#10+11]
> 13
> ```

### 转义字符

> \在Shell中被用作转义字符，用于去除紧跟其后的单个字符的特殊意义（回车除外），换句话说，紧跟其后的字符取字面值.
>
> 在\后敲回车表示续行，Shell并不会立刻执行命令，而是把光标移到下一行，给出一个续行提示符>，等待用户继续输入，最后把所有的续行接到一起当作一个命令执行